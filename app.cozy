
express = require('express')
stylus = require('stylus')
nib = require('nib')
util = require('util')

cli = require('cli')
MoeDB = require('./db.js').MoeDB

options = cli.parse
    db_path: ['d', 'SQLite database path', 'string']

db = new MoeDB(options.db_path)

app = express()

compile = (str, path) ->
    return stylus(str).set('filename', path).use(nib())

app.set('views', __dirname + '/views')
app.set('view engine', 'jade')
app.set('view options', { layout: false })
app.use(express.logger())
app.use(express.bodyParser())
app.use(express.cookieParser())
app.use(express.session(secret: "moe"))
app.use(stylus.middleware { src: __dirname + '/public', compile: compile})
app.use(express.static(__dirname + '/public'))

(error, req, res, next) <- app.use!
    console.log(error)
    res.send(500, {error: util.inspect(error)})

title_strs = ''
(err, rows) <- db.get_all_titles!
    titles = []
    for row in rows
        titles.push(row.title)
    title_strs = "\n" + titles.join("\n")
    console.log("MoeDict server is ready")

find_in_dict = (query, cb) ->

    col = "title"

    if /%$/.exec(query)
        #query = query.replace(/&$/, '')
        col = "def"
        query = "%#{query}"
        db.find_all_by_def(query, cb)
    else
        if (new_query = query.replace(/\$$/, '')) is query
            query += '%'
        else
            query = new_query

        db.find_all_by_title(query, cb)


(req, res) <- app.get('/q/:query', _)

    (err, rows) <- find_in_dict(req.params.query, _)
        for row in rows
            defs = row.def.split(/\n/)
            row.def = defs
            delete row.result
        res.send(rows)
 
(req, res) <- app.get('/q/web/:query', _)

    punctuations = ['，', '。', '（', '）', '「', '」']

    to_clickable = (def_str, loc) ->
        if loc >= def_str.length
            return ''

        step = 1
        last_sub_def_str = ''
        last_found_step = 0
        while loc + step < def_str.length
            sub_def_str = def_str.substr(loc, step)
            if punctuations.indexOf(sub_def_str.substr(sub_def_str.length - 1, 1)) is -1 and (found_index = title_strs.indexOf("\n" + sub_def_str) + 1) > 0
                if title_strs.substr(found_index + step, 1) is "\n"
                    last_sub_def_str = sub_def_str
                    last_found_step = step
            else
                return "<a href='##{last_sub_def_str}'>#{last_sub_def_str}</a>" + to_clickable(def_str, loc + last_found_step) if last_found_step >= 1
            step++

        def_str.substr(loc, 1) + to_clickable(def_str, loc + 1)

    (err, rows) <- find_in_dict(req.params.query, _)
        for row in rows
            defs = row.def.split(/\n/)
            linked_defs = []
            for def in defs
                linked_defs.push(to_clickable(def, 0))

            linked_defs[defs.length - 1] += """<script type="text/javascript">$("a").click(function(event) {
                return window.get_dict_content(event.target.text);
                });</script>"""
 
            row.def = linked_defs
            delete row.result

        res.send(rows)

(req, res) <- app.get('/q/title/:query', _)

    (err, rows) <- db.find_all_titles_by_title(req.params.query, _)
        res.send(rows)

(req, res) <- app.get('/', _)

    res.render('index')        
    
app.listen(8080)


